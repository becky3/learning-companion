# 自動進行管理（auto-progress） — レトロスペクティブ

## 概要

Issue #253「リポジトリ自動進行管理」の議論を通じて、IssueからPRマージまでの全工程を自動化する仕様書（`docs/specs/auto-progress.md`）を策定した。

- Issue: #253

## 実装の概要

- エージェントチームで多角的に議論
  - ユーザー・運用視点担当: コスト意識、運用負荷、事後拒否権モデルの提案
  - 技術・アーキテクチャ視点担当: ワークフロー設計、git-flow 評価、安全弁設計
  - ストーリーテラー: 議論の俯瞰、見落とし指摘
- 仕様書に記載した主要な設計判断:
  - `auto-implement` ラベルによるトリガー方式
  - auto-fix.yml によるレビュー→修正→再レビューの自動ループ
  - 簡易 git-flow（develop + main）の採用
  - 事後拒否権モデル（仕様書の事前承認不要）
  - 10層の安全弁設計
  - 自動マージレビューIssue方式（`auto:review-batch`）
  - GitHub 通知への統一（カスタム Slack 通知は不採用とする方針。既存ワークフローの通知ステップは今後削除予定）

## うまくいったこと

### 1. チームでの多角的議論

ユーザー・運用視点と技術視点の役割分担により、単一視点では見落としがちな論点を洗い出せた。特に以下が議論で改善された:

- 事後拒否権モデル: 承認ステップがボトルネックになる問題を運用視点担当が指摘し、「デフォルトは進む、止めたい時だけ止める」方式に
- git-flow 採用: develop ブランチをサンドボックスにすることで自動マージのリスクを軽減
- コスト見積もり: Phase 1/Phase 2 の段階的なコスト試算

### 2. ユーザーの随時フィードバックによる仕様改善

ユーザーが議論中に随時フィードバックを入れることで、方向性のズレを早期に修正できた。具体例:

- 「Slack通知は不要、GitHub通知で十分」→ カスタム Slack 通知は不採用とする方針（既存ワークフローの通知ステップは今後削除予定）
- 「Slackチェックリストより集約Issue方式が良い」→ 自動マージレビューIssue方式に変更
- 「機械可読フラグでレビュー結果をパースすべき」→ `<!-- auto-fix:no-issues -->` HTML コメント方式に

### 3. 段階的ロードマップ

Phase 0（最小構成）→ Phase 1（自動ループ）→ Phase 2（フルサイクル）の段階設計により、リスクを抑えつつ導入できる計画になった。

## ハマったこと・改善点

### 1. メンバーのコンテキスト切れによるファイル編集の遅延

**問題**: 長時間の議論でコンテキストウィンドウが圧迫され、ファイル編集タスクの着手が遅れた。分析メッセージの送信と実際のファイル編集が分離し、「分析は送ったがファイルはまだ」という状態が発生した。

**教訓**: ファイル編集タスクは、分析フェーズと分離せず「Read → 分析 → Edit」を一連の流れで実行させるべき。プロンプトに「分析メッセージを送る前にファイルを編集せよ」と明示する。

### 2. 分析メッセージの送り直しループ

**問題**: メッセージ配信のタイミングにより、リーダーに分析結果が届かず、同じ分析を複数回送り直すループが発生した。コンテキストを大量に消費する原因になった。

**教訓**: メンバーへの指示は「メッセージで分析を送れ」ではなく「ファイルを直接編集せよ」にすべき。ファイル編集は成果物として残るため、メッセージ配信の問題に影響されない。

### 3. 複数メンバーによる同一ファイル編集の競合

**問題**: 技術担当とライター（記述担当）が同じ仕様書を編集し、セクション内容やAC番号に不整合が発生した（AC5.1/5.2 と AC24-28 の重複など）。

**教訓**: 同一ファイルの編集は1名に集約する。複数メンバーが関わる場合は、セクション単位で明確に分担を決める。

## 次に活かすこと

1. **ファイル編集タスクは「Read → Edit → 完了報告」を一連の流れで実行させる**: 分析メッセージの送信とファイル編集を分離しない。プロンプトに「メッセージでの分析は不要、ファイルを直接編集せよ」と明示する

2. **同一ファイルの編集担当は1名に限定する**: 複数メンバーが同じファイルを編集すると不整合が発生する。担当者を明確にし、他メンバーは意見をメッセージで送る

3. **議論フェーズと記述フェーズを分ける**: 議論中にファイル編集を並行すると混乱する。議論で方針を固めてから、記述担当がまとめて反映する方が効率的

4. **ユーザーの随時フィードバックは仕様品質を大幅に向上させる**: 議論の途中でもユーザーが方向修正できる仕組み（チーム議論へのリアルタイム参加）は効果的

5. **カスタム通知より既存の通知インフラを活用する**: GitHub 通知 → Slack 連携など、ユーザーが既に構築済みの通知パイプラインを尊重し、ワークフロー内でのカスタム通知は避ける

---

## Phase 0 実装（Issue #256）

### 何を実装したか

`auto-implement` ラベルによる自動実装トリガーの最小構成を実装した。

- `.github/workflows/claude.yml` に `issues: [labeled]` トリガーを追加
- if 条件に `auto-implement` ラベル判定と `auto:failed` 除外ロジックを追加
- `CLAUDE.md` に「自動進行ルール（auto-progress）」セクションを追加

### うまくいったこと

#### 1. 既存条件との衝突回避が的確

既存の `issues` イベント（`opened`, `assigned`）に `labeled` を追加する際、`action != 'labeled'` で既存条件を保護し、新しい `auto-implement` 判定を別の条件として OR 追加する設計が的確だった。既存の `@claude` メンション機能に一切影響を与えずに新機能を追加できた。

#### 2. 仕様書テンプレートの活用

仕様書（`docs/specs/auto-progress.md`）に CLAUDE.md 追加セクションのテンプレートが定義済みだったため、CLAUDE.md への追記内容に迷いがなく、仕様書との完全一致を実現できた。

#### 3. 最小構成への集中

Phase 0 は「トリガーの追加」と「ルールの記載」のみに絞り、余計な機能（auto-fix ループ、自動マージ等）を含めなかった。変更ファイルが3つ（claude.yml, CLAUDE.md, retro）だけで、レビュー・テストの負荷が低く、安全に導入できる構成になった。

### ハマったこと・改善点

特に大きな問題は発生しなかった。Phase 0 は設計が十分に固まった状態で実装に入れたため、仕様書どおりにスムーズに進んだ。

### 次に活かすこと

1. **仕様書にテンプレートを用意しておくと実装がブレない**: CLAUDE.md 追加セクションのテンプレートが仕様書にあったおかげで、実装者が迷わず正確に反映できた。今後の仕様書でも、設定ファイルやドキュメントの追記内容はテンプレートとして明示すると良い

2. **Phase 分割は効果的**: 小さな変更から始めて段階的に拡張するアプローチにより、各Phase のリスクが限定される。Phase 1（auto-fix.yml + 自動マージ）に進む際も同様に最小構成から始めるべき

3. **GitHub Actions の if 条件は複雑化しやすい**: 条件が増えるたびに可読性が下がる。Phase 1 以降でさらに条件が増える場合は、composite action や reusable workflow への分離を検討する

---

## 品質チェックスキル作成（Issue #266）

### 何を実装したか

GitHub Actions 環境（claude-code-action）でサブエージェント（Task tool）が安定しない問題に対応し、品質チェック用スキル3種を作成した。

- `/test-run` スキル: pytest / ruff / mypy / markdownlint の実行（`.claude/skills/test-run/SKILL.md`）
- `/code-review` スキル: 変更差分のセルフコードレビュー（`.claude/skills/code-review/SKILL.md`）
- `/doc-review` スキル: ドキュメント品質レビュー（`.claude/skills/doc-review/SKILL.md`）
- 既存エージェント定義（test-runner.md, code-reviewer.md, doc-reviewer.md）をスキル参照に簡素化
- CLAUDE.md にスキル一覧追加、auto-progress セクションに品質チェック手順を追記

### うまくいったこと

#### 1. エージェント→スキルのリファクタリングが明確

エージェント定義の詳細ロジックをスキル（SKILL.md）に移行し、エージェント側は「スキルを Read して実行する」だけの薄いラッパーにする設計が明確だった。これにより:

- スキルとして直接呼び出し可能（GitHub Actions 環境向け）
- サブエージェント経由でも同じロジックを使用（ローカル環境向け）
- ロジックの重複が排除された

#### 2. 既存の仕様書・テスト資産がそのまま活用できた

スキルに移行しても、レビュー基準や実行手順の本質は変わらないため、既存の仕様書（`docs/specs/code-review-agent.md` 等）をそのまま参照先として維持できた。

### ハマったこと・改善点

#### 1. .gitignore による新規スキルファイルの除外

`.gitignore` で `.claude/` ディレクトリが除外されているため、新規スキルファイル3つが `git status` に表示されなかった。既存スキル（check-pr, doc-gen 等）は `git add -f` で強制追加されていたが、この手順が実装担当に伝わっていなかった。品質チェック担当が発見してコミット時に `git add -f` で対応した。

**教訓**: `.claude/skills/` 配下に新規ファイルを作成する際は `git add -f` が必要なことを、タスク説明に明記しておくべき。

### 次に活かすこと

1. **GitHub Actions 環境の制約はスキル化で解決できる**: サブエージェント（Task tool）が不安定な環境でも、スキル（SKILL.md）として定義すれば直接実行可能。環境差異への対応パターンとして有効

2. **エージェント定義は薄いラッパーにする**: 詳細ロジックはスキルに集約し、エージェントは「スキルを参照する」だけにすると、両方の呼び出しパターンに対応できる

3. **`.gitignore` 除外ディレクトリへの新規ファイル追加は要注意**: タスク定義時に `git add -f` の手順を明記する

---

## Phase 1 実装（Issue #257）

### 何を実装したか

PR作成後のレビュー → 指摘対応 → 再レビュー → マージ判定の全サイクルを自動化する3ファイルの変更・新規作成を行った。

**1. `.github/workflows/auto-fix.yml`（新規作成）**

- `workflow_run[completed]`（PR Review 完了時）トリガー
- PR番号特定: `workflow_run.pull_requests` 配列を優先、なければブランチ名から `gh pr list` でフォールバック
- `auto:failed` ラベルチェック → ループ回数チェック（最大3回） → レビュー結果判定（`<!-- auto-fix:no-issues -->` フラグ） → 禁止パターンチェック
- 指摘あり + 上限未到達: `claude-code-action` で `/check-pr` 実行 → `resolveReviewThread` → `BECKY3_PAT` で `/review` 再リクエスト
- 指摘なし: 4条件マージ判定（レビュー指摘ゼロ / CI全通過 / コンフリクトなし / auto:failedなし）
- 段階的マージ解禁 Step 1（ドライラン）: 判定結果をPRコメントに通知、実際のマージはコメントアウト
- エラー時の `auto:failed` 付与 + PRコメント + Actions ログリンク
- Slack通知（失敗時のみ）
- concurrency: ブランチ名ベース、cancel-in-progress: false

**2. `.github/workflows/pr-review.yml`（改修）**

- レビュー結果サマリーに機械可読フラグ（`<!-- auto-fix:no-issues -->` / `<!-- auto-fix:has-issues -->`）を埋め込むプロンプトを追加
- auto-fix.yml がレビュー結果を機械的に判定するために必要
- actor 条件の修正: BECKY3_PAT によるワークフロー連鎖を可能にするため、`github.actor` 条件を調整

**3. `.claude/skills/check-pr/SKILL.md`（改修）**

- ステップ12（コミット & push 後）に `resolveReviewThread` mutation による対応済みレビュースレッドの自動 resolve を追加
- GraphQL で未解決スレッドを取得 → 個別に resolve → 失敗は `::warning::` でログして次に継続
- ステップ番号を繰り下げ（12→14）

### うまくいったこと

#### 1. エージェントチームによる並行作業

エージェントチーム内で担当を分担し（auto-fix.yml 担当、pr-review.yml + check-pr SKILL.md 担当、品質チェック担当）、3ファイルを並行作成・改修できた。依存関係のない作業を分散させることで効率的に進行した。

#### 2. 仕様書の設計が十分に詳細だった

`docs/specs/auto-progress.md` の「auto-fix.yml 設計」セクションに処理フロー・分岐条件・使用シークレットが明記されていたため、実装時の判断に迷いがなかった。Phase 0 のレトロで「仕様書にテンプレートを用意しておくと実装がブレない」と記録した教訓が活きた。

#### 3. 既存ワークフローのパターン踏襲

pr-review.yml の構造（`set -euo pipefail`、PR番号バリデーション、`|| { ... }` エラーパターン）を auto-fix.yml でも踏襲し、一貫性を保てた。

### ハマったこと・改善点

#### 1. workflow_run イベントでのPR番号取得の制約

`workflow_run` イベントでは PR番号が事前に確定しないため、`concurrency` キーに直接使えない。`workflow_run.pull_requests` 配列が空になるケース（fork PRなど）もあり、ブランチ名からの `gh pr list` フォールバックが必要だった。仕様書ではPR番号ごとの concurrency を想定していたが、ブランチ名ベースで代替した。

#### 2. マージ方式の仕様書 vs ユーザー指示の不一致

仕様書では `gh pr merge --squash` と記載されていたが、ユーザー（管理者）から `--merge`（通常マージ）の指定があった。ユーザー指示を優先して `--merge` で実装した。仕様書の更新が必要。

#### 3. エラーハンドリングの振り子問題

初回実装では `|| true` でエラーを握り潰すパターンが多用されていた。レビュー指摘で修正したが、今度は全て `exit 1` で止めすぎる方向に振れた。5回のレビュー対応を経て、エラーの種類による3分類の方針に統一することで収束した:

- 認証/権限エラー → exit 1 で即停止
- 一時的API障害/ネットワーク → `::warning::` でログし続行
- データ不存在（PR未作成等） → ログ出力しスキップ

個別のエラーハンドリングを場当たり的に修正するのではなく、方針レベルで統一することが重要だった。

#### 4. resolveReviewThread の責務分離

当初 auto-fix.yml で全スレッドを一括 resolve する実装だったが、レビューで「未対応の指摘までクローズされる」と指摘された。resolve の責務を check-pr スキル内に集約し、ステップ7で「対応済み」と判断したスレッドのみを resolve する設計に変更した。auto-fix.yml 側の一括 resolve は削除。

#### 5. レビュー指摘対応後の品質チェック漏れ

初回実装後に品質チェック（code-review, doc-review, test-run）を通過したが、5回のレビュー修正ラウンドの間に品質チェックの再実施を忘れていた。複数ラウンドのレビュー対応時にも、最終コミット前に品質チェックを再実施する必要がある。

#### 6. 対応不要スレッドの resolve 漏れ

レビュー指摘に対して「対応不要」と判断した場合でも、スレッドを resolve しないと未解決として残り続ける。判断理由をコメントに残した上で resolve することで、レビュアーに意図を伝えつつスレッドを整理できる。

#### 7. 自動レビュー対応の戦術転換

ラウンド1-4では指摘が来るたびに即座に全員投入で個別対応した（反射的対応）。5ラウンド目でユーザーから「偵察してから戦え」と指示があり、全指摘の分類・分析を先に行ってから対応に入る方式に切り替えた。結果:

- 指摘の全容把握により、不要な人員投入を回避（1名で完了）
- ファイル単位の指摘集中度が判明し、担当の最適化が可能に
- 対応不要な指摘の事前判別ができた

5ラウンドの収束過程:

| ラウンド | 未解決件数 | 対応方式 |
|---------|-----------|---------|
| 1回目 | 16件 | 全員投入、個別対応 |
| 2回目 | 追加指摘 | 全員投入、個別対応 |
| 3回目 | 8件 | 2名投入、個別対応 |
| 4回目 | 10件 | 2名投入、方針統一を適用 |
| 5回目 | 4件 | 偵察先行→1名精密打撃 |

#### 8. 修正の連鎖反応（指摘面積の問題）

自動レビューツールは修正後のコードに対して再度レビューを実行するため、修正箇所が増えるほど新たな指摘が発生しやすい。特にガイドライン文書（SKILL.md）にコード例を追加すると、そのコード例自体がレビュー対象になり、エラーハンドリングの不備として再指摘される連鎖が発生した。

### 次に活かすこと

1. **`workflow_run` イベントのPR番号取得は2段階で**: `pull_requests` 配列 → ブランチ名検索のフォールバック。fork PRでは `pull_requests` が空になることを想定する

2. **仕様書とユーザー指示が矛盾する場合はユーザー指示を優先**: ただし、仕様書の更新を忘れずに行う

3. **concurrency 制御は利用可能な情報で**: workflow_run ではPR番号が不明なため、ブランチ名など確定情報で制御する

4. **エラーハンドリングは方針レベルで統一する**: 個別対応ではなく、エラーの種類（認証/一時的障害/データ不存在）による分類を先に決め、全箇所に一貫して適用する。場当たり的な修正は振り子問題を起こす

5. **resolve の責務は対応判断と同じ場所に置く**: 「対応済みかどうか」を判断するコンポーネント（check-pr スキル）が resolve も実行する。判断と実行を分離すると未対応スレッドの誤クローズが起きる

6. **複数ラウンドのレビュー対応でも品質チェックを再実施する**: 初回の品質チェック通過後でも、修正を重ねるたびにリグレッションが入る可能性がある。最終コミット前に必ず再チェック

7. **レビュー指摘対応は「偵察→方針→精密打撃」で進める**: 指摘が来たら即座に修正するのではなく、まず全指摘の分類・分析を行い、対応方針を決めてから着手する。反射的対応は人員・コンテキストの浪費につながる

8. **ガイドライン文書のコード例は指摘面積を意識する**: コード例を追加するとレビューツールの検査対象が増える。方針テーブルへの参照+最小限の例にとどめ、完全な実装例は避ける

## 参考

- 仕様書: [docs/specs/auto-progress.md](../specs/auto-progress.md)
- 関連Issue: #253（仕様策定）, #256（Phase 0 実装）, #257（Phase 1 実装）, #266（品質チェックスキル）
