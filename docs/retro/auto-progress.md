# 自動進行管理（auto-progress） — レトロスペクティブ

## 概要

Issue #253「リポジトリ自動進行管理」の議論を通じて、IssueからPRマージまでの全工程を自動化する仕様書（`docs/specs/auto-progress.md`）を策定した。

- Issue: #253

## 実装の概要

- エージェントチームで多角的に議論
  - ユーザー・運用視点担当: コスト意識、運用負荷、事後拒否権モデルの提案
  - 技術・アーキテクチャ視点担当: ワークフロー設計、git-flow 評価、安全弁設計
  - ストーリーテラー: 議論の俯瞰、見落とし指摘
- 仕様書に記載した主要な設計判断:
  - `auto-implement` ラベルによるトリガー方式
  - auto-fix.yml によるレビュー→修正→再レビューの自動ループ
  - 簡易 git-flow（develop + main）の採用
  - 事後拒否権モデル（仕様書の事前承認不要）
  - 10層の安全弁設計
  - 自動マージレビューIssue方式（`auto:review-batch`）
  - GitHub 通知への統一（カスタム Slack 通知は不採用とする方針。既存ワークフローの通知ステップは今後削除予定）

## うまくいったこと

### 1. チームでの多角的議論

ユーザー・運用視点と技術視点の役割分担により、単一視点では見落としがちな論点を洗い出せた。特に以下が議論で改善された:

- 事後拒否権モデル: 承認ステップがボトルネックになる問題を運用視点担当が指摘し、「デフォルトは進む、止めたい時だけ止める」方式に
- git-flow 採用: develop ブランチをサンドボックスにすることで自動マージのリスクを軽減
- コスト見積もり: Phase 1/Phase 2 の段階的なコスト試算

### 2. ユーザーの随時フィードバックによる仕様改善

ユーザーが議論中に随時フィードバックを入れることで、方向性のズレを早期に修正できた。具体例:

- 「Slack通知は不要、GitHub通知で十分」→ カスタム Slack 通知は不採用とする方針（既存ワークフローの通知ステップは今後削除予定）
- 「Slackチェックリストより集約Issue方式が良い」→ 自動マージレビューIssue方式に変更
- 「機械可読フラグでレビュー結果をパースすべき」→ `<!-- auto-fix:no-issues -->` HTML コメント方式に

### 3. 段階的ロードマップ

Phase 0（最小構成）→ Phase 1（自動ループ）→ Phase 2（フルサイクル）の段階設計により、リスクを抑えつつ導入できる計画になった。

## ハマったこと・改善点

### 1. メンバーのコンテキスト切れによるファイル編集の遅延

**問題**: 長時間の議論でコンテキストウィンドウが圧迫され、ファイル編集タスクの着手が遅れた。分析メッセージの送信と実際のファイル編集が分離し、「分析は送ったがファイルはまだ」という状態が発生した。

**教訓**: ファイル編集タスクは、分析フェーズと分離せず「Read → 分析 → Edit」を一連の流れで実行させるべき。プロンプトに「分析メッセージを送る前にファイルを編集せよ」と明示する。

### 2. 分析メッセージの送り直しループ

**問題**: メッセージ配信のタイミングにより、リーダーに分析結果が届かず、同じ分析を複数回送り直すループが発生した。コンテキストを大量に消費する原因になった。

**教訓**: メンバーへの指示は「メッセージで分析を送れ」ではなく「ファイルを直接編集せよ」にすべき。ファイル編集は成果物として残るため、メッセージ配信の問題に影響されない。

### 3. 複数メンバーによる同一ファイル編集の競合

**問題**: 技術担当とライター（記述担当）が同じ仕様書を編集し、セクション内容やAC番号に不整合が発生した（AC5.1/5.2 と AC24-28 の重複など）。

**教訓**: 同一ファイルの編集は1名に集約する。複数メンバーが関わる場合は、セクション単位で明確に分担を決める。

## 次に活かすこと

1. **ファイル編集タスクは「Read → Edit → 完了報告」を一連の流れで実行させる**: 分析メッセージの送信とファイル編集を分離しない。プロンプトに「メッセージでの分析は不要、ファイルを直接編集せよ」と明示する

2. **同一ファイルの編集担当は1名に限定する**: 複数メンバーが同じファイルを編集すると不整合が発生する。担当者を明確にし、他メンバーは意見をメッセージで送る

3. **議論フェーズと記述フェーズを分ける**: 議論中にファイル編集を並行すると混乱する。議論で方針を固めてから、記述担当がまとめて反映する方が効率的

4. **ユーザーの随時フィードバックは仕様品質を大幅に向上させる**: 議論の途中でもユーザーが方向修正できる仕組み（チーム議論へのリアルタイム参加）は効果的

5. **カスタム通知より既存の通知インフラを活用する**: GitHub 通知 → Slack 連携など、ユーザーが既に構築済みの通知パイプラインを尊重し、ワークフロー内でのカスタム通知は避ける

---

## Phase 0 実装（Issue #256）

### 何を実装したか

`auto-implement` ラベルによる自動実装トリガーの最小構成を実装した。

- `.github/workflows/claude.yml` に `issues: [labeled]` トリガーを追加
- if 条件に `auto-implement` ラベル判定と `auto:failed` 除外ロジックを追加
- `CLAUDE.md` に「自動進行ルール（auto-progress）」セクションを追加

### うまくいったこと

#### 1. 既存条件との衝突回避が的確

既存の `issues` イベント（`opened`, `assigned`）に `labeled` を追加する際、`action != 'labeled'` で既存条件を保護し、新しい `auto-implement` 判定を別の条件として OR 追加する設計が的確だった。既存の `@claude` メンション機能に一切影響を与えずに新機能を追加できた。

#### 2. 仕様書テンプレートの活用

仕様書（`docs/specs/auto-progress.md`）に CLAUDE.md 追加セクションのテンプレートが定義済みだったため、CLAUDE.md への追記内容に迷いがなく、仕様書との完全一致を実現できた。

#### 3. 最小構成への集中

Phase 0 は「トリガーの追加」と「ルールの記載」のみに絞り、余計な機能（auto-fix ループ、自動マージ等）を含めなかった。変更ファイルが3つ（claude.yml, CLAUDE.md, retro）だけで、レビュー・テストの負荷が低く、安全に導入できる構成になった。

### ハマったこと・改善点

特に大きな問題は発生しなかった。Phase 0 は設計が十分に固まった状態で実装に入れたため、仕様書どおりにスムーズに進んだ。

### 次に活かすこと

1. **仕様書にテンプレートを用意しておくと実装がブレない**: CLAUDE.md 追加セクションのテンプレートが仕様書にあったおかげで、実装者が迷わず正確に反映できた。今後の仕様書でも、設定ファイルやドキュメントの追記内容はテンプレートとして明示すると良い

2. **Phase 分割は効果的**: 小さな変更から始めて段階的に拡張するアプローチにより、各Phase のリスクが限定される。Phase 1（auto-fix.yml + 自動マージ）に進む際も同様に最小構成から始めるべき

3. **GitHub Actions の if 条件は複雑化しやすい**: 条件が増えるたびに可読性が下がる。Phase 1 以降でさらに条件が増える場合は、composite action や reusable workflow への分離を検討する

---

## 品質チェックスキル作成（Issue #266）

### 何を実装したか

GitHub Actions 環境（claude-code-action）でサブエージェント（Task tool）が安定しない問題に対応し、品質チェック用スキル3種を作成した。

- `/test-run` スキル: pytest / ruff / mypy / markdownlint の実行（`.claude/skills/test-run/SKILL.md`）
- `/code-review` スキル: 変更差分のセルフコードレビュー（`.claude/skills/code-review/SKILL.md`）
- `/doc-review` スキル: ドキュメント品質レビュー（`.claude/skills/doc-review/SKILL.md`）
- 既存エージェント定義（test-runner.md, code-reviewer.md, doc-reviewer.md）をスキル参照に簡素化
- CLAUDE.md にスキル一覧追加、auto-progress セクションに品質チェック手順を追記

### うまくいったこと

#### 1. エージェント→スキルのリファクタリングが明確

エージェント定義の詳細ロジックをスキル（SKILL.md）に移行し、エージェント側は「スキルを Read して実行する」だけの薄いラッパーにする設計が明確だった。これにより:

- スキルとして直接呼び出し可能（GitHub Actions 環境向け）
- サブエージェント経由でも同じロジックを使用（ローカル環境向け）
- ロジックの重複が排除された

#### 2. 既存の仕様書・テスト資産がそのまま活用できた

スキルに移行しても、レビュー基準や実行手順の本質は変わらないため、既存の仕様書（`docs/specs/code-review-agent.md` 等）をそのまま参照先として維持できた。

### ハマったこと・改善点

#### 1. .gitignore による新規スキルファイルの除外

`.gitignore` で `.claude/` ディレクトリが除外されているため、新規スキルファイル3つが `git status` に表示されなかった。既存スキル（check-pr, doc-gen 等）は `git add -f` で強制追加されていたが、この手順が実装担当に伝わっていなかった。品質チェック担当が発見してコミット時に `git add -f` で対応した。

**教訓**: `.claude/skills/` 配下に新規ファイルを作成する際は `git add -f` が必要なことを、タスク説明に明記しておくべき。

### 次に活かすこと

1. **GitHub Actions 環境の制約はスキル化で解決できる**: サブエージェント（Task tool）が不安定な環境でも、スキル（SKILL.md）として定義すれば直接実行可能。環境差異への対応パターンとして有効

2. **エージェント定義は薄いラッパーにする**: 詳細ロジックはスキルに集約し、エージェントは「スキルを参照する」だけにすると、両方の呼び出しパターンに対応できる

3. **`.gitignore` 除外ディレクトリへの新規ファイル追加は要注意**: タスク定義時に `git add -f` の手順を明記する

---

## Phase 1 実装（Issue #257）

### 何を実装したか

PR作成後のレビュー → 指摘対応 → 再レビュー → マージ判定の全サイクルを自動化する3ファイルの変更・新規作成を行った。

**1. `.github/workflows/auto-fix.yml`（新規作成）**

- `workflow_run[completed]`（PR Review 完了時）トリガー
- PR番号特定: `workflow_run.pull_requests` 配列を優先、なければブランチ名から `gh pr list` でフォールバック
- `auto:failed` ラベルチェック → ループ回数チェック（最大3回） → レビュー結果判定（`<!-- auto-fix:no-issues -->` フラグ） → 禁止パターンチェック
- 指摘あり + 上限未到達: `claude-code-action` で `/check-pr` 実行 → `resolveReviewThread` → `REPO_OWNER_PAT` で `/review` 再リクエスト
- 指摘なし: 4条件マージ判定（レビュー指摘ゼロ / CI全通過 / コンフリクトなし / auto:failedなし）
- 段階的マージ解禁 Step 1（ドライラン）: 判定結果をPRコメントに通知、実際のマージはコメントアウト
- エラー時の `auto:failed` 付与 + PRコメント + Actions ログリンク
- Slack通知（失敗時のみ）
- concurrency: ブランチ名ベース、cancel-in-progress: false

**2. `.github/workflows/pr-review.yml`（改修）**

- レビュー結果サマリーに機械可読フラグ（`<!-- auto-fix:no-issues -->` / `<!-- auto-fix:has-issues -->`）を埋め込むプロンプトを追加
- auto-fix.yml がレビュー結果を機械的に判定するために必要
- actor 条件の修正: REPO_OWNER_PAT によるワークフロー連鎖を可能にするため、`github.actor` 条件を調整

**3. `.claude/skills/check-pr/SKILL.md`（改修）**

- ステップ12（コミット & push 後）に `resolveReviewThread` mutation による対応済みレビュースレッドの自動 resolve を追加
- GraphQL で未解決スレッドを取得 → 個別に resolve → 失敗は `::warning::` でログして次に継続
- ステップ番号を繰り下げ（12→14）

### うまくいったこと

#### 1. エージェントチームによる並行作業

エージェントチーム内で担当を分担し（auto-fix.yml 担当、pr-review.yml + check-pr SKILL.md 担当、品質チェック担当）、3ファイルを並行作成・改修できた。依存関係のない作業を分散させることで効率的に進行した。

#### 2. 仕様書の設計が十分に詳細だった

`docs/specs/auto-progress.md` の「auto-fix.yml 設計」セクションに処理フロー・分岐条件・使用シークレットが明記されていたため、実装時の判断に迷いがなかった。Phase 0 のレトロで「仕様書にテンプレートを用意しておくと実装がブレない」と記録した教訓が活きた。

#### 3. 既存ワークフローのパターン踏襲

pr-review.yml の構造（`set -euo pipefail`、PR番号バリデーション、`|| { ... }` エラーパターン）を auto-fix.yml でも踏襲し、一貫性を保てた。

### ハマったこと・改善点

#### 1. workflow_run イベントでのPR番号取得の制約

`workflow_run` イベントでは PR番号が事前に確定しないため、`concurrency` キーに直接使えない。`workflow_run.pull_requests` 配列が空になるケース（fork PRなど）もあり、ブランチ名からの `gh pr list` フォールバックが必要だった。仕様書ではPR番号ごとの concurrency を想定していたが、ブランチ名ベースで代替した。

#### 2. マージ方式の仕様書 vs ユーザー指示の不一致

仕様書では `gh pr merge --squash` と記載されていたが、ユーザー（管理者）から `--merge`（通常マージ）の指定があった。ユーザー指示を優先して `--merge` で実装した。仕様書の更新が必要。

#### 3. エラーハンドリングの振り子問題

初回実装では `|| true` でエラーを握り潰すパターンが多用されていた。レビュー指摘で修正したが、今度は全て `exit 1` で止めすぎる方向に振れた。5回のレビュー対応を経て、エラーの種類による3分類の方針に統一することで収束した:

- 認証/権限エラー → exit 1 で即停止
- 一時的API障害/ネットワーク → `::warning::` でログし続行
- データ不存在（PR未作成等） → ログ出力しスキップ

個別のエラーハンドリングを場当たり的に修正するのではなく、方針レベルで統一することが重要だった。

#### 4. resolveReviewThread の責務分離

当初 auto-fix.yml で全スレッドを一括 resolve する実装だったが、レビューで「未対応の指摘までクローズされる」と指摘された。resolve の責務を check-pr スキル内に集約し、ステップ7で「対応済み」と判断したスレッドのみを resolve する設計に変更した。auto-fix.yml 側の一括 resolve は削除。

#### 5. レビュー指摘対応後の品質チェック漏れ

初回実装後に品質チェック（code-review, doc-review, test-run）を通過したが、5回のレビュー修正ラウンドの間に品質チェックの再実施を忘れていた。複数ラウンドのレビュー対応時にも、最終コミット前に品質チェックを再実施する必要がある。

#### 6. 対応不要スレッドの resolve 漏れ

レビュー指摘に対して「対応不要」と判断した場合でも、スレッドを resolve しないと未解決として残り続ける。判断理由をコメントに残した上で resolve することで、レビュアーに意図を伝えつつスレッドを整理できる。

#### 7. 自動レビュー対応の戦術転換

ラウンド1-4では指摘が来るたびに即座に全員投入で個別対応した（反射的対応）。5ラウンド目でユーザーから「偵察してから戦え」と指示があり、全指摘の分類・分析を先に行ってから対応に入る方式に切り替えた。結果:

- 指摘の全容把握により、不要な人員投入を回避（1名で完了）
- ファイル単位の指摘集中度が判明し、担当の最適化が可能に
- 対応不要な指摘の事前判別ができた

5ラウンドの収束過程:

| ラウンド | 未解決件数 | 対応方式 |
|---------|-----------|---------|
| 1回目 | 16件 | 全員投入、個別対応 |
| 2回目 | 追加指摘 | 全員投入、個別対応 |
| 3回目 | 8件 | 2名投入、個別対応 |
| 4回目 | 10件 | 2名投入、方針統一を適用 |
| 5回目 | 4件 | 偵察先行→1名精密打撃 |

#### 8. 修正の連鎖反応（指摘面積の問題）

自動レビューツールは修正後のコードに対して再度レビューを実行するため、修正箇所が増えるほど新たな指摘が発生しやすい。特にガイドライン文書（SKILL.md）にコード例を追加すると、そのコード例自体がレビュー対象になり、エラーハンドリングの不備として再指摘される連鎖が発生した。

### 次に活かすこと

1. **`workflow_run` イベントのPR番号取得は2段階で**: `pull_requests` 配列 → ブランチ名検索のフォールバック。fork PRでは `pull_requests` が空になることを想定する

2. **仕様書とユーザー指示が矛盾する場合はユーザー指示を優先**: ただし、仕様書の更新を忘れずに行う

3. **concurrency 制御は利用可能な情報で**: workflow_run ではPR番号が不明なため、ブランチ名など確定情報で制御する

4. **エラーハンドリングは方針レベルで統一する**: 個別対応ではなく、エラーの種類（認証/一時的障害/データ不存在）による分類を先に決め、全箇所に一貫して適用する。場当たり的な修正は振り子問題を起こす

5. **resolve の責務は対応判断と同じ場所に置く**: 「対応済みかどうか」を判断するコンポーネント（check-pr スキル）が resolve も実行する。判断と実行を分離すると未対応スレッドの誤クローズが起きる

6. **複数ラウンドのレビュー対応でも品質チェックを再実施する**: 初回の品質チェック通過後でも、修正を重ねるたびにリグレッションが入る可能性がある。最終コミット前に必ず再チェック

7. **レビュー指摘対応は「偵察→方針→精密打撃」で進める**: 指摘が来たら即座に修正するのではなく、まず全指摘の分類・分析を行い、対応方針を決めてから着手する。反射的対応は人員・コンテキストの浪費につながる

8. **ガイドライン文書のコード例は指摘面積を意識する**: コード例を追加するとレビューツールの検査対象が増える。方針テーブルへの参照+最小限の例にとどめ、完全な実装例は避ける

---

## Phase 1 残課題対応（Issue #288）

### 何を実装したか

Phase 1 運用で発覚した3つの問題を修正した。

**A. auto-fix.yml の direct_prompt 書き換え**

- GA環境では Skill ツール（`/check-pr` スキル呼び出し）が機能しないことが PR #287 で判明
- `direct_prompt` を `/check-pr` スキル呼び出しから、check-pr SKILL.md の手順を直接記述する形式に変更
- CLAUDE.md の品質チェック手順（GA環境向け直接記述パターン）と同じアプローチ

**B. AUTO_MERGE_ENABLED 変数による段階的マージ解禁**

- ドライランステップをハードコードのコメントアウトから `vars.AUTO_MERGE_ENABLED` による動的分岐に変更
- `== "true"` パターンで安全側フォールバック（未設定/false 時はドライラン維持）
- Repository Variable で切り替え可能にし、コード変更なしでマージ解禁・停止が可能に

**C. auto-implement ラベルの自動除去**

- auto-implement ラベルがIssue側で剥がれない問題（#284, #286 で発生）の対応
- auto-fix.yml の scope-check 直後に、PRのbodyから Closes/Fixes/Resolves パターンでIssue番号を抽出し、ラベルを除去するステップを追加
- 冪等性を確保（ラベル不存在時もエラーにならない）

### うまくいったこと

#### 1. GA環境制約への対応パターンが確立

Issue #266（品質チェックスキル作成）で確立した「Skill ツール不使用、直接記述」パターンを auto-fix にも適用できた。direct_prompt 内に check-pr の全手順を 7ステップで記述し、SKILL.md の 14ステップ構成を簡潔に圧縮しつつ、主要機能を全てカバーできた。

#### 2. 安全側フォールバックの設計

AUTO_MERGE_ENABLED の実装で `== "true"` パターンを採用し、未設定時・不正値時はドライランにフォールバックする設計。Repository Variable の設定ミスや削除があっても安全に動作する。

### ハマったこと・改善点

特に大きな問題は発生しなかった。変更内容が明確で、既存パターンの適用がメインだったため、スムーズに進行した。

### 次に活かすこと

1. **GA環境でのSkill ツール制約は direct_prompt で回避する**: スキルの手順を直接記述することで、サブエージェント/スキルが使えない環境でも同等の処理が実行可能。このパターンは今後の GA ワークフロー追加時にも適用する

2. **段階的解禁は Repository Variable で制御する**: コード変更なしで切り替えできるため、緊急時の停止も迅速。ワークフローの on/off 制御には vars を活用する

3. **ラベル操作は冪等に設計する**: ラベルの有無にかかわらずエラーにならないようにすることで、ワークフローの再実行時にも安全に動作する

---

## Phase 2 実装: post-merge.yml + shellcheck 統合（Issue #310）

### 何を実装したか

PRマージ後の自動処理ワークフロー `post-merge.yml` を新規作成し、併せて shellcheck をテストスキルに統合した。

**1. `.github/workflows/post-merge.yml`（新規作成）**

- `pull_request[closed]` + `merged == true` トリガー
- 3段構成: 変更ファイル分類 → review-batch Issue 更新 → 次Issue候補ピックアップ
- `GITHUB_TOKEN` のみ使用（ワークフロー連鎖不要のため PAT 不要）
- Slack通知（失敗時のみ）、concurrency: PR番号ベース

**2. `.github/scripts/post-merge/`（3スクリプト新規作成）**

- `classify-changes.sh`: PR変更ファイルを取得し、`src/*`, `config/*`, `mcp-servers/*`, `pyproject.toml` にマッチするか判定
- `update-review-issue.sh`: `auto:review-batch` ラベルの Open Issue を検索し、追記 or 新規作成+ピン留め。チェックリストはファイルパターンからテンプレート生成
- `pick-next-issue.sh`: 次の `auto-implement` 候補Issue（最大3件）をPRコメントに投稿。ラベル自動付与はしない（CLAUDE.md ルール準拠）

**3. shellcheck のテストスキル統合**

- `shellcheck-py` を pyproject.toml の dev 依存に追加（`uv run shellcheck` で実行可能）
- `/test-run` スキルに shellcheck ステップを追加（ステップ7）
- CLAUDE.md のコーディング規約・GitHub Actions 品質チェックコマンドに追加

**4. `docs/specs/auto-progress.md` の仕様書整理**

- `release.yml`（定期リリースPR）の全記述を削除
- `auto-triage.yml`（Issue自動分析）の全記述を削除
- Phase 2 セクションを post-merge.yml のみに再構成
- 安全弁を10層→9層に振り直し（変更規模制限の削除に伴い）
- コスト見積もり、AC、関連ファイルテーブルを更新

### うまくいったこと

#### 1. 既存パターンの活用で設計がスムーズ

auto-fix スクリプト群（`_common.sh` の3段階エラーハンドリング、`require_env` / `validate_pr_number` パターン）を post-merge スクリプトでも踏襲した。`_common.sh` を相対パスで source する設計により、コード重複なしで共通関数を再利用できた。

#### 2. shellcheck 統合による即時フィードバック

shellcheck を導入した直後に、新規スクリプトの CRLF 問題と既存スクリプトの改善点（SC2129, SC2016 等）を即座に検出できた。既存スクリプトの指摘は別Issue（#313）に切り出し、スコープを明確に分離した。

#### 3. ラベル自動付与の回避が設計に組み込まれた

CLAUDE.md + MEMORY.md の「`auto-implement` ラベルを勝手に付けるな」ルールに従い、`pick-next-issue.sh` では候補の通知のみ行い、ラベル付与は管理者判断とした。コードレビューでもこの点は指摘なし。

### ハマったこと・改善点

#### 1. Windows 環境での CRLF 問題

Write ツールで作成したシェルスクリプトが CRLF 改行になっており、shellcheck の SC1017 エラーが大量に発生した。`tr -d '\r'` で変換して対応。`.shellcheckrc` も同様に CRLF だった。

**教訓**: Windows 環境でシェルスクリプトを作成する際は、必ず LF 改行に変換する。`.gitattributes` で `*.sh text eol=lf` を設定すべき（#313 で対応予定）。

#### 2. shellcheck の glob 展開問題

`uv run shellcheck .github/scripts/**/*.sh` は `globstar` が有効なシェルでしか再帰展開されない。ubuntu-latest のデフォルト bash では `**` は単一ディレクトリレベルのみマッチ。コードレビューで指摘され、明示的パス（`auto-fix/*.sh .github/scripts/post-merge/*.sh`）に変更した。

**教訓**: GitHub Actions 環境で `**` glob を使う場合は `shopt -s globstar` が必要。もしくは明示パスか `find` を使う。

#### 3. shellcheck-py による環境ポータブルなインストール

shellcheck のインストール方法として `shellcheck-py`（Python パッケージ）を採用した。`uv` のdev依存に追加するだけで、Windows/macOS/Linux 全てで `uv run shellcheck` が使える。scoop/brew/apt 等の OS 固有のパッケージマネージャーが不要。

### 次に活かすこと

1. **シェルスクリプト作成時は LF 改行を徹底する**: Windows 環境では CRLF がデフォルト。`.gitattributes` での強制と、CI での shellcheck による検出の二重防御を構築する

2. **静的解析ツールは dev 依存で管理する**: `shellcheck-py` のように Python パッケージとして提供されるツールは `pyproject.toml` の dev 依存に追加することで、環境構築が `uv sync --extra dev` だけで完結する

3. **glob の `**` パターンは環境依存**: `globstar` オプションの有無で動作が変わる。CI/CD 環境では明示パスか `find` を使う方が確実

4. **新しい静的解析ツール導入時は既存コードも検査する**: 新規ファイルだけでなく既存ファイルにも指摘が出る。スコープ管理のために既存コードの修正は別Issue に切り出す

## レースコンディション設計見直し（Issue #357, #360）

### 何が起きたか

自動実装パイプラインで3つの問題が発覚した（Issue #357 で2問題、その修正試行中に1問題）。

1. **PRKit レースコンディション**: `claude-auto-implement` がPR作成後の別ステップで `auto:pipeline` ラベルを付与するが、`pull_request[opened]` イベントはPR作成直後に発火するため、`pr-review.yml` のスキップ条件（ラベル判定）が間に合わない
2. **Copilot is not a user エラー**: `copilot-auto-fix.yml` のトリガー時 `github.actor` が Copilot になり、`claude-code-action` の権限チェックで拒否された → `allowed_bots: "Copilot"` で解決（PR #358）
3. **GITHUB_TOKEN への変更の副作用**: 問題1の修正として `REPO_OWNER_PAT` → `GITHUB_TOKEN` に変更したが、Copilot の自動レビューのトリガーも消失した → ロールバック必要

### 試みた解決策と失敗

| 方法 | 結果 |
|------|------|
| `GITHUB_TOKEN` に変更 | PRKit は止まったが Copilot レビューも止まった |
| ブランチ名 `claude/issue-*` でフィルタ | `@claude` 手動指示でも同じ命名で区別不能 |
| CLAUDE.md に `--label auto:pipeline` ルール追加 | その場しのぎと判断された |

### チーム設計議論（Issue #360）

mixed-genius チームで根本設計を見直した。

#### 問題の本質

- `auto:pipeline` ラベルのスキップ判定は**構造的にレースコンディションに弱い**。ラベルはPR作成のアトミック操作に含められない
- `GITHUB_TOKEN` と `REPO_OWNER_PAT` はトレードオフ関係にある。`GITHUB_TOKEN` は全ての後続ワークフローを抑制し、`REPO_OWNER_PAT` は全てを発火させる

#### 確定した解決策: branch_prefix 方式

`claude-code-action` の `branch_prefix` パラメータで auto-implement 由来のPRをブランチプレフィックスで判定する。

| 用途 | 手段 | タイミング依存 |
|------|------|--------------|
| ワークフロー制御 | `branch_prefix: "auto/"` | 不要（PR作成時にアトミック確定） |
| 検索・フィルタ（人間用） | `auto:pipeline` ラベル | 不要（遅延許容） |

**変更内容**:

1. `claude.yml`: `REPO_OWNER_PAT` に戻す + `branch_prefix: "auto/"` 追加
2. `pr-review.yml`: スキップ判定をラベル → ブランチプレフィックス（ステップレベル、ログ追跡性のため）
3. `copilot-auto-fix.yml`: 前提条件をラベル → ブランチプレフィックス（ジョブレベル、Actions分数節約）
4. `auto:pipeline` ラベルは検索・フィルタ用に残す（ワークフロー判定からは外す）

### うまくいったこと

#### 1. チーム議論で解決策の多角的評価ができた

複数の解決策を2人が独立に分析し、トレードオフを定量評価（10年後の保守性スコア）できた。最終的に両者の推奨が収束し、方針の信頼性が高まった。

#### 2. ユーザーの問いかけが設計を洗練させた

- 「`auto:pipeline` ラベルいらなくなるのでは？」→ ワークフロー制御とフィルタ用途の分離に発展
- 「タイトルに [AUTO] つけるか」→ ラベルの検索機能の方が有用と再評価
- 「`@claude` PRのPRKitレビューも止まるのでは」→ `branch_prefix` による完全分離の必要性が明確に

#### 3. 実データによる裏取り

メンバーがリモートブランチの実名称を調査し、正規表現パターンの精度を実証した。

### ハマったこと・改善点

#### 1. 前セッションでの副作用調査不足

`REPO_OWNER_PAT` → `GITHUB_TOKEN` 変更時に、コメントに設計意図が明記されていたにも関わらず、Copilot レビューへの影響を見落とした。「修正 → 副作用 → 別の修正」のループに入ってから止められた。

#### 2. その場しのぎの連鎖を断つ判断が遅かった

3つの修正案が却下されてから初めて「根本設計を見直す」判断に至った。1つ目の修正で副作用が出た時点で立ち止まるべきだった。

### 次に活かすこと

1. **CI/CDの変更は影響範囲が広い**: 1つのトークン変更がPRKit、Copilot、下流ワークフロー全てに波及する。変更前に「このコンポーネントが他の何に依存されているか」を調査する

2. **ラベルによるワークフロー制御はレースコンディションに弱い**: ラベルはPR作成のアトミック操作に含められない。ブランチ名、actor、イベントタイプなど、イベントペイロードに含まれる情報で判定する方が堅牢

3. **修正の副作用が出たら立ち止まる**: 「修正 → 副作用 → 別の修正」のループに入ったら、個別の修正を続けるのではなく根本設計を見直す判断をする

4. **既存コメントの設計意図を尊重する**: コードに理由が明記されている場合、変更前に「なぜこうなっているか」を深く理解する

## 参考

- 仕様書: [docs/specs/auto-progress.md](../specs/auto-progress.md)
- 関連Issue: #253（仕様策定）, #256（Phase 0 実装）, #257（Phase 1 実装）, #266（品質チェックスキル）, #288（Phase 1 残課題対応）, #310（Phase 2: post-merge.yml）, #313（既存スクリプト shellcheck 修正）, #357（ワークフロー修正）, #360（レースコンディション設計見直し）
