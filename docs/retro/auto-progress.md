# 自動進行管理（auto-progress） — レトロスペクティブ

## 概要

Issue #253「リポジトリ自動進行管理」の議論を通じて、IssueからPRマージまでの全工程を自動化する仕様書（`docs/specs/auto-progress.md`）を策定した。

- Issue: #253

## 実装の概要

- エージェントチーム（ONE PIECE テーマ）で多角的に議論
  - ナミ（ユーザー・運用視点）: コスト意識、運用負荷、事後拒否権モデルの提案
  - フランキー（技術・アーキテクチャ視点）: ワークフロー設計、git-flow 評価、安全弁設計
  - ニコ・ロビン（ストーリーテラー）: 議論の俯瞰、見落とし指摘
- 仕様書に記載した主要な設計判断:
  - `auto-implement` ラベルによるトリガー方式
  - auto-fix.yml によるレビュー→修正→再レビューの自動ループ
  - 簡易 git-flow（develop + main）の採用
  - 事後拒否権モデル（仕様書の事前承認不要）
  - 10層の安全弁設計
  - 自動マージレビューIssue方式（`auto:review-batch`）
  - GitHub 通知への統一（カスタム Slack 通知は不採用とする方針。既存ワークフローの通知ステップは今後削除予定）

## うまくいったこと

### 1. チームでの多角的議論

ユーザー・運用視点（ナミ）と技術視点（フランキー）の役割分担により、単一視点では見落としがちな論点を洗い出せた。特に以下が議論で改善された:

- 事後拒否権モデル: 承認ステップがボトルネックになる問題をナミが指摘し、「デフォルトは進む、止めたい時だけ止める」方式に
- git-flow 採用: develop ブランチをサンドボックスにすることで自動マージのリスクを軽減
- コスト見積もり: Phase 1/Phase 2 の段階的なコスト試算

### 2. ユーザーの随時フィードバックによる仕様改善

ユーザーが議論中に随時フィードバックを入れることで、方向性のズレを早期に修正できた。具体例:

- 「Slack通知は不要、GitHub通知で十分」→ カスタム Slack 通知は不採用とする方針（既存ワークフローの通知ステップは今後削除予定）
- 「Slackチェックリストより集約Issue方式が良い」→ 自動マージレビューIssue方式に変更
- 「機械可読フラグでレビュー結果をパースすべき」→ `<!-- auto-fix:no-issues -->` HTML コメント方式に

### 3. 段階的ロードマップ

Phase 0（最小構成）→ Phase 1（自動ループ）→ Phase 2（フルサイクル）の段階設計により、リスクを抑えつつ導入できる計画になった。

## ハマったこと・改善点

### 1. メンバーのコンテキスト切れによるファイル編集の遅延

**問題**: 長時間の議論でコンテキストウィンドウが圧迫され、ファイル編集タスクの着手が遅れた。分析メッセージの送信と実際のファイル編集が分離し、「分析は送ったがファイルはまだ」という状態が発生した。

**教訓**: ファイル編集タスクは、分析フェーズと分離せず「Read → 分析 → Edit」を一連の流れで実行させるべき。プロンプトに「分析メッセージを送る前にファイルを編集せよ」と明示する。

### 2. 分析メッセージの送り直しループ

**問題**: メッセージ配信のタイミングにより、リーダーに分析結果が届かず、同じ分析を複数回送り直すループが発生した。コンテキストを大量に消費する原因になった。

**教訓**: メンバーへの指示は「メッセージで分析を送れ」ではなく「ファイルを直接編集せよ」にすべき。ファイル編集は成果物として残るため、メッセージ配信の問題に影響されない。

### 3. 複数メンバーによる同一ファイル編集の競合

**問題**: フランキー（技術担当）とライター（記述担当）が同じ仕様書を編集し、セクション内容やAC番号に不整合が発生した（AC5.1/5.2 と AC24-28 の重複など）。

**教訓**: 同一ファイルの編集は1名に集約する。複数メンバーが関わる場合は、セクション単位で明確に分担を決める。

## 次に活かすこと

1. **ファイル編集タスクは「Read → Edit → 完了報告」を一連の流れで実行させる**: 分析メッセージの送信とファイル編集を分離しない。プロンプトに「メッセージでの分析は不要、ファイルを直接編集せよ」と明示する

2. **同一ファイルの編集担当は1名に限定する**: 複数メンバーが同じファイルを編集すると不整合が発生する。担当者を明確にし、他メンバーは意見をメッセージで送る

3. **議論フェーズと記述フェーズを分ける**: 議論中にファイル編集を並行すると混乱する。議論で方針を固めてから、記述担当がまとめて反映する方が効率的

4. **ユーザーの随時フィードバックは仕様品質を大幅に向上させる**: 議論の途中でもユーザーが方向修正できる仕組み（チーム議論へのリアルタイム参加）は効果的

5. **カスタム通知より既存の通知インフラを活用する**: GitHub 通知 → Slack 連携など、ユーザーが既に構築済みの通知パイプラインを尊重し、ワークフロー内でのカスタム通知は避ける

---

## Phase 0 実装（Issue #256）

### 何を実装したか

`auto-implement` ラベルによる自動実装トリガーの最小構成を実装した。

- `.github/workflows/claude.yml` に `issues: [labeled]` トリガーを追加
- if 条件に `auto-implement` ラベル判定と `auto:failed` 除外ロジックを追加
- `CLAUDE.md` に「自動進行ルール（auto-progress）」セクションを追加

### うまくいったこと

#### 1. 既存条件との衝突回避が的確

既存の `issues` イベント（`opened`, `assigned`）に `labeled` を追加する際、`action != 'labeled'` で既存条件を保護し、新しい `auto-implement` 判定を別の条件として OR 追加する設計が的確だった。既存の `@claude` メンション機能に一切影響を与えずに新機能を追加できた。

#### 2. 仕様書テンプレートの活用

仕様書（`docs/specs/auto-progress.md`）に CLAUDE.md 追加セクションのテンプレートが定義済みだったため、CLAUDE.md への追記内容に迷いがなく、仕様書との完全一致を実現できた。

#### 3. 最小構成への集中

Phase 0 は「トリガーの追加」と「ルールの記載」のみに絞り、余計な機能（auto-fix ループ、自動マージ等）を含めなかった。変更ファイルが3つ（claude.yml, CLAUDE.md, retro）だけで、レビュー・テストの負荷が低く、安全に導入できる構成になった。

### ハマったこと・改善点

特に大きな問題は発生しなかった。Phase 0 は設計が十分に固まった状態で実装に入れたため、仕様書どおりにスムーズに進んだ。

### 次に活かすこと

1. **仕様書にテンプレートを用意しておくと実装がブレない**: CLAUDE.md 追加セクションのテンプレートが仕様書にあったおかげで、実装者が迷わず正確に反映できた。今後の仕様書でも、設定ファイルやドキュメントの追記内容はテンプレートとして明示すると良い

2. **Phase 分割は効果的**: 小さな変更から始めて段階的に拡張するアプローチにより、各Phase のリスクが限定される。Phase 1（auto-fix.yml + 自動マージ）に進む際も同様に最小構成から始めるべき

3. **GitHub Actions の if 条件は複雑化しやすい**: 条件が増えるたびに可読性が下がる。Phase 1 以降でさらに条件が増える場合は、composite action や reusable workflow への分離を検討する

---

## 品質チェックスキル作成（Issue #266）

### 何を実装したか

GitHub Actions 環境（claude-code-action）でサブエージェント（Task tool）が安定しない問題に対応し、品質チェック用スキル3種を作成した。

- `/test-run` スキル: pytest / ruff / mypy / markdownlint の実行（`.claude/skills/test-run/SKILL.md`）
- `/code-review` スキル: 変更差分のセルフコードレビュー（`.claude/skills/code-review/SKILL.md`）
- `/doc-review` スキル: ドキュメント品質レビュー（`.claude/skills/doc-review/SKILL.md`）
- 既存エージェント定義（test-runner.md, code-reviewer.md, doc-reviewer.md）をスキル参照に簡素化
- CLAUDE.md にスキル一覧追加、auto-progress セクションに品質チェック手順を追記

### うまくいったこと

#### 1. エージェント→スキルのリファクタリングが明確

エージェント定義の詳細ロジックをスキル（SKILL.md）に移行し、エージェント側は「スキルを Read して実行する」だけの薄いラッパーにする設計が明確だった。これにより:

- スキルとして直接呼び出し可能（GitHub Actions 環境向け）
- サブエージェント経由でも同じロジックを使用（ローカル環境向け）
- ロジックの重複が排除された

#### 2. 既存の仕様書・テスト資産がそのまま活用できた

スキルに移行しても、レビュー基準や実行手順の本質は変わらないため、既存の仕様書（`docs/specs/code-review-agent.md` 等）をそのまま参照先として維持できた。

### ハマったこと・改善点

#### 1. .gitignore による新規スキルファイルの除外

`.gitignore` で `.claude/` ディレクトリが除外されているため、新規スキルファイル3つが `git status` に表示されなかった。既存スキル（check-pr, doc-gen 等）は `git add -f` で強制追加されていたが、この手順が実装担当に伝わっていなかった。品質チェック担当が発見してコミット時に `git add -f` で対応した。

**教訓**: `.claude/skills/` 配下に新規ファイルを作成する際は `git add -f` が必要なことを、タスク説明に明記しておくべき。

### 次に活かすこと

1. **GitHub Actions 環境の制約はスキル化で解決できる**: サブエージェント（Task tool）が不安定な環境でも、スキル（SKILL.md）として定義すれば直接実行可能。環境差異への対応パターンとして有効

2. **エージェント定義は薄いラッパーにする**: 詳細ロジックはスキルに集約し、エージェントは「スキルを参照する」だけにすると、両方の呼び出しパターンに対応できる

3. **`.gitignore` 除外ディレクトリへの新規ファイル追加は要注意**: タスク定義時に `git add -f` の手順を明記する

---

## Phase 1 実装（Issue #257）

### 何を実装したか

PR作成後のレビュー → 指摘対応 → 再レビュー → マージ判定の全サイクルを自動化する3ファイルの変更・新規作成を行った。

**1. `.github/workflows/auto-fix.yml`（新規作成）**

- `workflow_run[completed]`（PR Review 完了時）トリガー
- PR番号特定: `workflow_run.pull_requests` 配列を優先、なければブランチ名から `gh pr list` でフォールバック
- `auto:failed` ラベルチェック → ループ回数チェック（最大3回） → レビュー結果判定（`<!-- auto-fix:no-issues -->` フラグ） → 禁止パターンチェック
- 指摘あり + 上限未到達: `claude-code-action` で `/check-pr` 実行 → `resolveReviewThread` → `BECKY3_PAT` で `/review` 再リクエスト
- 指摘なし: 4条件マージ判定（レビュー指摘ゼロ / CI全通過 / コンフリクトなし / auto:failedなし）
- 段階的マージ解禁 Step 1（ドライラン）: 判定結果をPRコメントに通知、実際のマージはコメントアウト
- エラー時の `auto:failed` 付与 + PRコメント + Actions ログリンク
- Slack通知（失敗時のみ）
- concurrency: ブランチ名ベース、cancel-in-progress: false

**2. `.github/workflows/pr-review.yml`（改修）**

- レビュー結果サマリーに機械可読フラグ（`<!-- auto-fix:no-issues -->` / `<!-- auto-fix:has-issues -->`）を埋め込むプロンプトを追加
- auto-fix.yml がレビュー結果を機械的に判定するために必要
- actor 条件の修正: BECKY3_PAT によるワークフロー連鎖を可能にするため、`github.actor` 条件を調整

**3. `.claude/skills/check-pr/SKILL.md`（改修）**

- ステップ12（コミット & push 後）に `resolveReviewThread` mutation による対応済みレビュースレッドの自動 resolve を追加
- GraphQL で未解決スレッドを取得 → 個別に resolve → 失敗は `::warning::` でログして次に継続
- ステップ番号を繰り下げ（12→14）

### うまくいったこと

#### 1. エージェントチームによる並行作業

進撃の巨人テーマのチーム（リヴァイ: auto-fix.yml、ハンジ: pr-review.yml + check-pr SKILL.md、ミカサ: 品質チェック）で3ファイルを並行作成・改修できた。依存関係のない作業を分散させることで効率的に進行した。

#### 2. 仕様書の設計が十分に詳細だった

`docs/specs/auto-progress.md` の「auto-fix.yml 設計」セクションに処理フロー・分岐条件・使用シークレットが明記されていたため、実装時の判断に迷いがなかった。Phase 0 のレトロで「仕様書にテンプレートを用意しておくと実装がブレない」と記録した教訓が活きた。

#### 3. 既存ワークフローのパターン踏襲

pr-review.yml の構造（`set -euo pipefail`、PR番号バリデーション、`|| { ... }` エラーパターン）を auto-fix.yml でも踏襲し、一貫性を保てた。

### ハマったこと・改善点

#### 1. workflow_run イベントでのPR番号取得の制約

`workflow_run` イベントでは PR番号が事前に確定しないため、`concurrency` キーに直接使えない。`workflow_run.pull_requests` 配列が空になるケース（fork PRなど）もあり、ブランチ名からの `gh pr list` フォールバックが必要だった。仕様書ではPR番号ごとの concurrency を想定していたが、ブランチ名ベースで代替した。

#### 2. マージ方式の仕様書 vs ユーザー指示の不一致

仕様書では `gh pr merge --squash` と記載されていたが、ユーザー（管理者）から `--merge`（通常マージ）の指定があった。ユーザー指示を優先して `--merge` で実装した。仕様書の更新が必要。

### 次に活かすこと

1. **`workflow_run` イベントのPR番号取得は2段階で**: `pull_requests` 配列 → ブランチ名検索のフォールバック。fork PRでは `pull_requests` が空になることを想定する

2. **仕様書とユーザー指示が矛盾する場合はユーザー指示を優先**: ただし、仕様書の更新を忘れずに行う

3. **concurrency 制御は利用可能な情報で**: workflow_run ではPR番号が不明なため、ブランチ名など確定情報で制御する

## 参考

- 仕様書: [docs/specs/auto-progress.md](../specs/auto-progress.md)
- 関連Issue: #253（仕様策定）, #256（Phase 0 実装）, #257（Phase 1 実装）, #266（品質チェックスキル）
