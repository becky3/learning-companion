# F9: RAGナレッジ機能 — レトロスペクティブ

## 概要

外部Webページから収集した知識をベクトルDBに蓄積し、ユーザーの質問に関連する情報を自動検索してチャット応答に活用するRAG（Retrieval-Augmented Generation）機能を実装した。

## 実装範囲

| Issue | タイトル | 状態 |
|-------|---------|------|
| #119 | F9: RAGナレッジ機能の実装（親Issue） | 完了 |
| #114 | 仕様書作成 | 完了 |
| #115 | Embeddingプロバイダーの実装 | 完了 |
| #116 | RAGインフラの実装（チャンキング・ベクトルストア） | 完了 |
| #117 | Webクローラーの実装 | 完了 |
| #118 | RAGナレッジサービスの実装と既存コード統合 | 完了 |
| #161 | アンカー違いの重複取り込み防止 | 完了 |
| #176 | RAG評価・可視化 Phase 2（類似度閾値フィルタリング） | 完了 |
| #158 | crawl進捗フィードバック追加 | 完了 |
| #195 | チャンキング改善・ハイブリッド検索 | 基盤実装完了 |
| #216 | ハイブリッド検索のRAGKnowledgeService統合 | 完了（PR #217） |
| #177 | RAG評価・可視化 Phase 3: 自動評価パイプライン | 完了（PR #219） |
| #160 | robots.txt の解析・遵守 | 完了 |

関連PR: #120, #121, #151, #152, #154, #155, #156, #187, #192, #211, #217, #219, #237

## 主なコンポーネント

```
src/embedding/           — Embeddingプロバイダー（LM Studio/OpenAI切替）
src/rag/
├── chunker.py           — テキストチャンキング
├── content_detector.py  — コンテンツタイプ検出（テーブル/見出し/散文）
├── table_chunker.py     — テーブル行分割（ヘッダー保持）
├── heading_chunker.py   — 見出しベースチャンキング
├── bm25_index.py        — BM25キーワードインデックス（fugashi日本語トークナイザー）
├── hybrid_search.py     — RRFベースハイブリッド検索
├── vector_store.py      — ChromaDBラッパー
├── evaluation.py        — Precision/Recall計算、評価レポート生成
└── cli.py               — 評価CLIエントリポイント
src/services/
├── web_crawler.py       — SSRF対策付きWebクローラー
└── rag_knowledge.py     — オーケストレーションサービス
```

**Slackコマンド:**

- `@bot rag crawl <URL> [パターン]` — リンク集から一括取り込み（進捗フィードバック付き）
- `@bot rag add <URL>` — 単一ページ取り込み
- `@bot rag status` — 統計表示
- `@bot rag delete <URL>` — 削除

**評価CLI:**

```bash
python -m src.rag.cli evaluate   # RAG検索精度評価
python -m src.rag.cli init-test-db  # テスト用ChromaDB初期化
```

---

## うまくいったこと

### 1. 仕様駆動開発の徹底

- 先に詳細な仕様書を作成してから実装に入った
- 受け入れ条件（AC）を定義し、テスト名と対応づけ
- 実装中に仕様変更が必要になった場合も、先に仕様書を更新してから実装

### 2. 既存パターンの再利用

| パターン | 参照元 | 適用先 |
|---------|--------|--------|
| 抽象基底クラス | `LLMProvider` | `EmbeddingProvider` |
| ファクトリ関数 | `get_provider_for_service()` | `get_embedding_provider()` |
| 同期APIラップ | `feed_collector.py` | ChromaDB操作 |
| オプショナル注入 | `ThreadHistoryService` | `RAGKnowledgeService` |
| コマンドルーティング | `feed` コマンド | `rag` コマンド |

### 3. セキュリティ対策の事前設計

SSRF対策を仕様書段階で明確化：

- ドメインホワイトリスト（必須）
- スキーム制限（http/httpsのみ）
- リダイレクト追従無効化
- クロール遅延・ページ数制限

### 4. テスト設計

- `chromadb.EphemeralClient()` でファイルシステム副作用なしにテスト
- AC番号ベースのテスト命名でトレーサビリティ確保

### 5. モジュラー設計（チャンキング改善）

各コンポーネントを独立してテスト可能な形で実装：

| コンポーネント | テスト数 | 特徴 |
|---------------|---------|------|
| ContentTypeDetector | 6 | 境界値テストを含む |
| TableChunker | 4 | ヘッダー保持確認 |
| HeadingChunker | 4 | 見出し階層処理 |
| BM25Index | 7 | 日本語トークン化 |
| HybridSearch | 5 | RRFスコア計算 |

### 6. 既存コードの活用（自動評価）

Phase 2 で作成した `evaluation.py` の評価関数群をそのまま活用し、新規追加はCLIラッパーとレポート出力のみ。

### 7. エージェントチームによる並行開発

チーム編成で効率的に作業を分担し、レビュー対応やテスト作成を並行実施。

---

## 改善点・ハマったこと

### 1. ChromaDBテレメトリのエラー

**問題**: ChromaDBがデフォルトでテレメトリを送信しようとし、失敗時にエラーログが出力された。

**対応**: `ChromaSettings(anonymized_telemetry=False)` でテレメトリ無効化。

**教訓**: 外部ライブラリのデフォルト動作（テレメトリ、ログ出力等）を事前に確認する。

### 2. Pythonバージョン変更の波及

**問題**: sentence-transformers（onnxruntime）がPython 3.11以上を要求。テスト実行時にエラー発生。

**対応**: `.python-version`, `pyproject.toml`, `README.md` など複数ファイルを更新。

**教訓**: 依存パッケージ追加時はPythonバージョン要件を事前確認。ML系ライブラリは特にバージョン制約が厳しい。

### 3. アンカー違いの重複取り込み

**問題**: `rag crawl` で同一ページのアンカー違い（`#m`, `#movie`等）が別ページとして取り込まれた。

**対応**: PR #187 で `validate_url()` に `urldefrag()` を追加し、重複排除を実装。

**教訓**: クローラーのURL正規化は早期に実装すべき。重複データの蓄積は後からのクリーンアップが困難。

### 4. Settings()の毎回インスタンス化

**問題**: `ChatService.respond()` 内で毎回 `Settings()` をインスタンス化していた。

**対応**: `get_settings()` （キャッシュ済み）を使用するよう修正。

### 5. crawl中のフィードバック不足（解決済み: PR #237）

**問題**: クロール処理中、完了までSlackで反応がなく状況がわからない。

**対応**: `progress_callback` パターンでサービス層とハンドラ層を疎結合にし、スレッド内にリアルタイム進捗を投稿。

**教訓**: 長時間処理には進捗フィードバックが必要。コールバックパターンで層を分離するとテストも書きやすい。

### 6. 根本原因分析の不足（Phase 2, Issue #176）

**問題**: 「りゅうおう」検索が動かない事象に対し、「Embeddingモデルの日本語対応が弱い」と早合点し、モデル変更を提案した。

**実際の原因**: チャンクの中身が数値テーブルデータ中心で、短いクエリとの距離が遠くなるのは**チャンキング戦略とコンテンツ構造の問題**だった。

**対応**: Issue #194（Embeddingモデル変更）をクローズし、Issue #195（チャンキング改善・ハイブリッド検索）として正しい課題を起票。

**教訓**:

- 表面的な現象から解決策に飛びつかない
- データの中身を先に確認する
- ベクトル検索の特性を理解する — 同じテキストを含んでいても、周囲のコンテキストでベクトルは大きく変わる
- 仮説を立てたら検証してから行動する

### 7. 外部ドメインクローリングのセキュリティ脆弱性（Critical）

**問題**: `crawl_index_page()` が外部ドメインへのリンクもクロールしていた。

**発見経緯**: ユーザーの運用テスト中にMcAfeeが外部サイトへのアクセスをブロック。

**根本原因**: Issue のコメントで「外部サイトにアクセスしない」と明言されていたが、仕様書のACに反映されなかった。

**教訓**: Issue のコメントも仕様に反映する。SSRF対策（IP検証）とドメイン制限は別レイヤーで両方必要。

### 8. BM25テストの失敗

**問題**: BM25の IDF計算式で N=2, n=1 の場合に IDF=0 となり、スコアが0になる。

**対応**: テストのドキュメント数を2から3に変更。

**教訓**: BM25は少数ドキュメントでの評価に不向き。数式の特性を理解してテストデータを設計する。

### 9. mypy の型チェック設定

**問題**: `fugashi` と `rank_bm25` が型スタブを提供しておらず、mypy strict モードでエラー。

**対応**: `untyped_calls_exclude` と `overrides` で対応。

**教訓**: 型スタブのないパッケージは事前に確認する。ML/NLP系ライブラリは型サポートが弱いことが多い。

### 10. コメントと実装の不一致

**問題**: `_split_by_sentences()` のコメントが実装の正規表現と不一致。

**対応**: コメントを実装に合わせて修正。

**教訓**: コメントを書く際は実装と正確に一致させる。レビュー時はコメントと実装の整合性も確認する。

### 11. 著作権問題（Phase 3）

**問題**: テストデータ作成時に、実在のゲームシリーズの情報をそのまま使用してしまった。

**対応**: 架空のRPG「勇者の冒険」に完全置き換え。

**教訓**: テストデータは最初から架空のコンテンツで作成すべき。

### 12. 環境変数の副作用（Phase 3）

**問題**: `create_rag_service()` 関数で `os.environ["RAG_SIMILARITY_THRESHOLD"]` を直接上書きしている。

**教訓**: テスト時の設定変更は `monkeypatch` やテスト用設定オブジェクトを使用する。

### 13. Copilotレビュー指摘の多発（計41件）

**問題**: PR #211 に対して3回にわたり計41件のCopilotレビュー指摘。

**根本原因**: テスト名をAC番号形式で書かなかった、実装後に仕様書を更新しなかった、コミット前にlint実行しなかった。

**対応**: エージェントチームに最終チェック担当を追加。

---

## 今後の課題（Issue化済み）

| Issue | 内容 | 状態 |
|-------|------|------|
| #157 | ドメイン許可リストをSlackから動的管理 | 未着手 |
| #159 | URL安全性チェック（Google Safe Browsing API） | 未着手 |
| #160 | robots.txt の解析・遵守 | 完了 |
| #195 | チャンキング改善・ハイブリッド検索（残: 評価・閾値調整） | 進行中 |
| - | ベースラインの初期作成 | 未着手 |
| - | 環境変数副作用の解消 | 未着手 |

---

## 次に活かすこと

1. **外部ライブラリのデフォルト動作を確認する** — テレメトリ、ログレベル、ネットワーク接続等
2. **URL正規化は早期に実装する** — フラグメント除去、末尾スラッシュ統一など
3. **長時間処理には進捗フィードバックを設計に含める** — クローラー、バッチ処理など
4. **設定値の取得はキャッシュ経由で** — `get_settings()` パターンを使用
5. **仕様書のコード例は実装と整合させる** — 型の違い（`list[str]` vs `str`）など細部も確認
6. **問題の根本原因を特定してから解決策を提案する** — 表面的な現象から解決策に飛びつかない。まずデータの中身を確認し、仮説を検証する
7. **ベクトル検索の特性を理解する** — 同じキーワードを含んでいても、チャンク全体のコンテキストでベクトルは大きく変わる
8. **Issue のコメントも仕様に反映する** — Issue本文だけでなく、コメントで追加された要件・制約も見落とさない
9. **クローラーの外部リンク制限は最初から実装する** — SSRF対策とドメイン制限は別レイヤー
10. **テストデータは数式の特性を考慮して設計する** — BM25のIDF計算のように、少数データで評価できないアルゴリズムがある
11. **テスト名は最初からAC番号形式（`test_ac{N}_...`）で書く** — 後から修正すると大量の手戻り
12. **実装と仕様書は同時に更新する** — 閾値やシグネチャが変わったら即座に仕様書も修正
13. **コミット前チェックを習慣化する** — ruff/mypy/markdownlintをコミット前に毎回実行
14. **チームに最終チェック担当を置く** — 実装者のセルフチェックだけでは見落としが多い
15. **テストデータに実在の著作物を使用しない** — 最初から架空のコンテンツで作成する
16. **環境変数の上書きは避ける** — `monkeypatch` やテスト用設定オブジェクトを使用する

## 参考

- 仕様書: [docs/specs/f9-rag.md](../specs/f9-rag.md)
- ガイド: [docs/guides/rag-overview.md](../guides/rag-overview.md)
