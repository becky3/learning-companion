# F2: 情報収集・配信 — レトロスペクティブ

## 何を実装したか

RSSフィードからの記事自動収集・LLM要約・Slack配信の一連のパイプラインを実装した。

主な機能:
- RSS収集 + ローカルLLM要約 + Slack Block Kit配信（フィード別スレッド形式）
- Slackコマンドによるフィード管理（add/delete/enable/disable/list/import/replace/export）
- 要約スキップ収集モード（`feed collect --skip-summary`）
- 配信済みフラグによる重複配信防止
- OGP画像表示、配信カード形式切替（horizontal/vertical）
- 定時自動配信スケジューラ

関連PR: #14, #26, #30, #58, #61, #66, #71, #95, #103, #124, #132, #135

## うまくいったこと

- **仕様駆動開発**: `docs/specs/f2-feed-collection.md` を先に書いてから実装する流れが機能し、受け入れ条件ベースのテスト（AC1〜AC18）で品質を担保できた
- **逐次投稿アーキテクチャ**: `on_article_ready` コールバック方式により、1記事ずつ収集→即配信する設計が柔軟に機能した。skip-summary統合時もこのパターンに乗せるだけで対応できた
- **Block Kit共通関数**: `_build_article_blocks` / `_deliver_feed_to_slack` を共通化し、通常配信・テスト配信・手動配信で同じ表示ロジックを使えた
- **CSV import/replace/export**: フィード管理のCRUDをSlackコマンドで完結させ、サーバーにログインせずに運用できる設計

## 改善点・ハマったこと

### 1. skip-summary実装時のコード重複（PR #135）

**問題**: `_collect_feed` と90%同じロジックを持つ `_collect_feed_skip_summary` を別メソッドとして作成してしまった。

**原因**: 既存コードを読まずに新機能を追加した。`feed test` コマンドで既に要約スキップのパターンが存在していたが、それを参考にしなかった。

**対応**: `skip_summary: bool` フラグを既存メソッドに追加する形にリファクタリング。CLAUDE.mdに「実装前に既存コードを必ず読む」ルールを追加。

**教訓**: 新機能追加時は、まず既存コードのパラメータ追加で対応できないか検討する。

### 2. skip-summaryの配信フロー設計ミス

**問題**: skip-summary時に `delivered=True` で保存する仕様にしてしまい、記事がSlackに投稿されなかった。

**原因**: 「要約スキップ＝配信不要」と誤解して仕様書を書いた。実際のユーザー意図は「要約だけスキップして、配信は通常通り行う」。

**対応**: `delivered=True` を廃止し、`daily_collect_and_deliver(skip_summary=True)` で通常配信フローに統合。

**教訓**: 機能の目的を正確に理解してから仕様書を書く。「スキップ」が何をスキップするのか明確にする。

### 3. RSS 1.0形式での日付取得失敗（gihyo.jp）

**問題**: gihyo.jpのRSS 1.0フィードでは `pubDate` がなく `dc:date` のみ。feedparserは `dc:date` を `updated_parsed` に格納するが、コードは `published_parsed` のみ参照していたため `published_at=NULL` で609件保存された。

**対応**: `published_parsed` → `updated_parsed` のフォールバックを追加。gihyo.jpのフィードURLをRSS 2.0版（`/feed/rss2`）に変更。

**教訓**: feedparserの日付マッピングはRSS形式によって異なる。`published_parsed` だけでなく `updated_parsed` も確認する。

### 4. 過去記事の大量収集問題（OpenAI News 789件）

**問題**: OpenAI NewsのRSSに2017年からの全記事（789件）が含まれており、初回収集で全件取り込んでしまった。`max_articles_per_feed=10` のため1回の配信では10件しか配信されず、大量の未配信記事が残留。

**対応**: `.env` に `FEED_COLLECT_DAYS=7` 設定を追加。`_collect_feed` で `published_at` がN日以前の記事をスキップするフィルタを実装。

**教訓**: RSSフィードの記事数はサイトによって大きく異なる（数件〜数百件）。収集時に日付カットオフを設けるべき。

### 5. パッケージ名衝突（src/mcp）

**問題**: `src/mcp/` ディレクトリが外部パッケージ `mcp` と衝突し、`python src/main.py` 実行時に `ImportError` が発生。

**対応**: `src/mcp/` → `src/mcp_bridge/` にリネーム。

**教訓**: ディレクトリ名は外部パッケージと衝突しない名前を選ぶ。特に `python <file>` 実行時はカレントディレクトリがsys.pathに入るため注意。

### 6. Bot重複起動問題

**問題**: `uv run python -m src.main` で起動した子プロセス（MCPサーバー等）がbot停止時に残存し、次回起動で重複インスタンスが発生。Slackメッセージが二重処理される。

**対応**: Issue #136 として起動スクリプト方式（PIDファイル管理）での対策を計画中。

**教訓**: 子プロセスを生成するアプリケーションでは、起動・停止のライフサイクル管理が必要。

### 7. Slack Rate Limit

**問題**: 71フィード×最大50記事の逐次投稿で、Slack APIのRate Limitに抵触するリスクがあった。

**対応**: スレッド投稿間に1秒のスリープを入れることで緩和。ただし大量記事の場合は完了まで長時間かかる。

**教訓**: 外部API連携では Rate Limit を常に意識する。大量処理時はバッチ分割やRate Limit検知→リトライの仕組みが必要になる場合がある。

## 次に活かすこと

1. **既存コードを必ず読んでから実装する** — 新機能は既存メソッドのパラメータ追加で対応できないかまず検討する
2. **仕様書の前にユーザー意図を確認する** — 「スキップ」「省略」等の曖昧な要件は、何をスキップし何は維持するのか明確にしてから仕様化する
3. **外部データソースの特性を調査する** — RSSフィードは形式（RSS 1.0/2.0/Atom）や収録件数がサイトごとに大きく異なる。実データでの検証が重要
4. **運用テストで初めて見つかる問題がある** — 重複起動、Rate Limit、大量データ等はユニットテストだけでは検出しにくい。本番に近い環境での動作確認を早期に行う
5. **日付カットオフ等の安全弁を初期設計に含める** — 「全件取得」がデフォルトの設計は、想定外のデータ量で破綻しやすい
